import { existsSync, mkdtempSync, readdirSync, rmSync } from 'node:fs';
import { join, resolve } from 'node:path';
import process from 'node:process';
import { tmpdir } from 'node:os';
import {
  ExchangeState,
  StaticMockOrderbook,
  createReplayController,
  type MergedEvent,
  type ReplayProgress,
  type SymbolId,
} from '@tradeforge/core';
import { buildDepthReader, buildTradesReader } from '../_shared/readers.js';
import { buildMerged } from '../_shared/merge.js';
import { runScenario } from '../_shared/replay.js';
import { createLogger } from '../_shared/logging.js';
import { formatCheckpointSummary, makeCp } from '../_shared/checkpoint.js';

const logger = createLogger({ prefix: '[examples/05-pause-auto-checkpoint]' });

const SYMBOL = 'BTCUSDT' as SymbolId;

const SYMBOL_CONFIG = {
  base: 'BTC',
  quote: 'USDT',
  priceScale: 2,
  qtyScale: 4,
};

const state = new ExchangeState({
  symbols: { [SYMBOL as unknown as string]: SYMBOL_CONFIG },
  fee: { makerBps: 0, takerBps: 0 },
  orderbook: new StaticMockOrderbook({ best: {} }),
});

function delay(ms: number): Promise<void> {
  if (ms <= 0) return Promise.resolve();
  return new Promise((resolveDelay) => {
    setTimeout(resolveDelay, ms);
  });
}

function parseNumberEnv(key: string, fallback: number): number {
  const raw = process.env[key];
  if (!raw) return fallback;
  const parsed = Number(raw);
  return Number.isFinite(parsed) ? parsed : fallback;
}

function resolveCheckpointPath(): {
  path: string;
  tempDir?: string;
  autoGenerated: boolean;
} {
  const explicit = process.env['TF_CP_PATH'];
  if (explicit && explicit.trim().length > 0) {
    return { path: explicit.trim(), autoGenerated: false };
  }
  const tempDir = mkdtempSync(join(tmpdir(), 'tf-cp-'));
  return {
    path: resolve(tempDir, 'checkpoint.json'),
    tempDir,
    autoGenerated: true,
  };
}

function safeCursor<T>(readCursor: () => T): T | undefined {
  try {
    return readCursor();
  } catch (err) {
    logger.warn(
      `failed to read cursor for checkpoint: ${
        err instanceof Error ? err.message : String(err)
      }`,
    );
    return undefined;
  }
}

async function main(): Promise<void> {
  const {
    path: checkpointPath,
    tempDir,
    autoGenerated,
  } = resolveCheckpointPath();
  const keepCheckpoint = process.env['TF_KEEP_CP'] === '1';

  if (existsSync(checkpointPath)) {
    rmSync(checkpointPath);
    logger.info(`removed previous checkpoint at ${checkpointPath}`);
  }
  logger.info(`checkpoint file will be saved to ${checkpointPath}`);

  const dataRoot = resolve(process.cwd(), 'examples', '_smoke');
  const tradesPath = resolve(dataRoot, 'mini-trades.jsonl');
  const depthPath = resolve(dataRoot, 'mini-depth.jsonl');

  const trades = buildTradesReader([tradesPath]);
  const depth = buildDepthReader([depthPath]);
  const timeline = buildMerged(trades, depth);

  const controller = createReplayController();

  const resumeDelayMs = parseNumberEnv('TF_PAUSE_MS', 150);
  const slowdownMs = Number(process.env['TF_EXAMPLE_EVENT_DELAY'] ?? '120');
  const cpIntervalEvents = parseNumberEnv('TF_CP_INTERVAL_EVENTS', 20);
  const cpIntervalWallMs = parseNumberEnv('TF_CP_INTERVAL_WALL_MS', 500);

  let lastProgress: ReplayProgress | undefined;
  let lastEvent: MergedEvent | undefined;

  const runPromise = runScenario({
    timeline,
    clock: 'logical',
    limits: { maxEvents: 100 },
    controller,
    pauseOnStart: true,
    logger,
    autoCp: {
      savePath: checkpointPath,
      cpIntervalEvents,
      cpIntervalWallMs,
      buildCheckpoint: async () => {
        const tradesCursor = safeCursor(() => trades.currentCursor());
        const depthCursor = safeCursor(() => depth.currentCursor());
        const noteParts: string[] = [];
        if (lastProgress) {
          noteParts.push(`events=${lastProgress.eventsOut}`);
          if (lastProgress.simLastTs !== undefined) {
            noteParts.push(`simLast=${String(lastProgress.simLastTs)}`);
          }
        }
        if (lastEvent) {
          noteParts.push(`last=${lastEvent.source}:${String(lastEvent.ts)}`);
        }
        const checkpoint = makeCp({
          symbol: SYMBOL,
          state,
          cursors: {
            ...(tradesCursor ? { trades: tradesCursor } : {}),
            ...(depthCursor ? { depth: depthCursor } : {}),
          },
          merge: { nextSourceOnEqualTs: 'DEPTH' },
          note: noteParts.length > 0 ? noteParts.join(' ') : 'auto-checkpoint',
        });
        logger.info(
          `auto-checkpoint snapshot -> ${formatCheckpointSummary(checkpoint)}`,
        );
        return checkpoint;
      },
    },
    onEvent: async (event) => {
      lastEvent = event;
      if (slowdownMs > 0) {
        await delay(slowdownMs);
      }
    },
    onProgress: (progress) => {
      lastProgress = progress;
    },
  });

  logger.info(
    `controller paused on start â€” will resume automatically in ${resumeDelayMs}ms`,
  );
  const resumeTimer = setTimeout(
    () => {
      logger.info('resuming replay now');
      controller.resume();
    },
    Math.max(0, resumeDelayMs),
  );

  const progress = await runPromise;
  clearTimeout(resumeTimer);

  logger.info(`replay finished: processed ${progress.eventsOut} events`);

  const checkpointExists = existsSync(checkpointPath);
  if (checkpointExists) {
    logger.info(`checkpoint file saved at ${checkpointPath}`);
  } else {
    logger.warn(`checkpoint file not found at ${checkpointPath}`);
  }

  const summary = { cpExists: checkpointExists, cpPath: checkpointPath };
  console.log('PAUSE_CP_OK', JSON.stringify(summary));

  if (checkpointExists && !keepCheckpoint) {
    try {
      rmSync(checkpointPath);
      logger.info(`removed checkpoint at ${checkpointPath}`);
    } catch (err) {
      logger.warn(
        `failed to remove checkpoint at ${checkpointPath}: ${
          err instanceof Error ? err.message : String(err)
        }`,
      );
    }
    if (autoGenerated && tempDir) {
      try {
        if (existsSync(tempDir)) {
          const contents = readdirSync(tempDir);
          if (contents.length === 0) {
            rmSync(tempDir, { recursive: true });
            logger.info(`removed checkpoint temp dir ${tempDir}`);
          }
        }
      } catch (err) {
        logger.debug(
          `failed to remove temp checkpoint dir ${tempDir}: ${
            err instanceof Error ? err.message : String(err)
          }`,
        );
      }
    }
  }
}

main().catch((err) => {
  logger.error(err instanceof Error ? err.message : String(err));
  if (err instanceof Error && err.stack) {
    logger.debug(err.stack);
  }
  process.exit(1);
});
