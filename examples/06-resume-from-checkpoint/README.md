# 06 — Возобновление из Checkpoint v1

Эксперимент демонстрирует двухшаговый сценарий: сначала симуляция TradeForge сохраняет снимок состояния (Checkpoint v1), затем отдельный запуск загружает его и продолжает воспроизведение ровно с того же места и на тех же входных данных. На практике это позволяет разбивать длительные реплеи на этапы и возобновлять процесс после паузы или падения.

## Требования

- Установленные зависимости (`pnpm install`).
- Сборка рабочих пакетов (`pnpm -w build`).
- Сборка примеров (`pnpm -w examples:build`) — генерирует `dist-examples/**`.
- Мини-фикстуры из [`examples/_smoke`](../_smoke/) (используются по умолчанию, можно переопределить через `TF_TRADES_FILES` / `TF_DEPTH_FILES`).

> Чекпоинт хранит абсолютные курсоры по каждому источнику. Для успешного возобновления нужны ровно те же файлы, что участвовали при сохранении. Имя сверяется без учёта расширений `.gz` / `.zip`, поэтому `depth.jsonl`, `depth.jsonl.gz` и `depth.jsonl.zip` считаются эквивалентными базовыми именами.

## Шаг 1. Сохранить checkpoint

### Вариант CLI

1. Укажем файлы сделок и стакана (можно перечислить несколько через запятую или перевод строки):

   ```bash
   export TF_TRADES_FILES="examples/_smoke/mini-trades.jsonl"
   export TF_DEPTH_FILES="examples/_smoke/mini-depth.jsonl"
   ```

2. Запустим CLI с ограничением по событиям и путём для чекпоинта. Флаг `--checkpoint-save` включает автосохранение, а `--cp-interval-events` гарантирует запись после каждых 6 событий (в примере подбираем короткий отрезок):

   ```bash
   pnpm --filter @tradeforge/cli dev -- simulate \
     --trades "$TF_TRADES_FILES" \
     --depth "$TF_DEPTH_FILES" \
     --clock logical \
     --max-events 6 \
     --checkpoint-save /tmp/tf-ex06.cp.json \
     --cp-interval-events 6
   ```

   В stdout появится строка вроде `checkpoint saved to /tmp/tf-ex06.cp.json`. Файл содержит снимок движка, сериализованное состояние, курсоры по входным данным и настройки merge.

### Вариант SDK

1. Собираем примеры (`pnpm -w examples:build`).
2. Запускаем подготовленный сценарий `save.ts`:

   ```bash
   node dist-examples/06-resume-from-checkpoint/save.js
   ```

   Скрипт считывает мини-файлы из `_smoke`, проигрывает первые 6 событий и сохраняет чекпоинт в уникальный путь `/tmp/tf-ex06-XXXXXX/checkpoint.v1.json`. Итоговая строка `SAVE_OK { cpPath: "...", eventsOut: 6 }` содержит реальное расположение файла — оно понадобится на втором шаге.

## Шаг 2. Возобновить из checkpoint

### Вариант CLI

1. Используем тот же набор файлов и добавляем флаг `--checkpoint-load` с путём до сохранённого снимка:

   ```bash
   pnpm --filter @tradeforge/cli dev -- simulate \
     --trades "$TF_TRADES_FILES" \
     --depth "$TF_DEPTH_FILES" \
     --clock logical \
     --checkpoint-load /tmp/tf-ex06.cp.json
   ```

   CLI загрузит `Checkpoint v1`, восстановит состояние (`ExchangeState` + активные ордера) и продолжит чтение данных с курсоров, сохранённых в файле. Если базовые имена входных файлов отличаются, появится предупреждение.

### Вариант SDK

1. Передаём путь к чекпоинту скрипту `resume.ts` (можно через аргумент CLI или переменную `TF_CP_PATH`):

   ```bash
   node dist-examples/06-resume-from-checkpoint/resume.js /tmp/tf-ex06-XXXXXX/checkpoint.v1.json
   ```

   Скрипт загружает `Checkpoint v1`, сверяет базовые имена входных файлов, восстанавливает сериализованное состояние и запускает реплей, начиная с сохранённых курсоров. Финальная строка `RESUME_OK { loaded: true, eventsOutDelta: ..., cpPath: "..." }` подтверждает успешное продолжение.

## Что внутри Checkpoint v1

Формат `Checkpoint v1` объединяет несколько частей:

- `state` — сериализованный `ExchangeState` со всеми балансами, ордерами и конфигурацией символов.
- `engine` — снапшот движка исполнения (открытые/стоп-ордера и рабочая очередь).
- `cursors` — позиция по каждому источнику данных (файл + индекс записи), чтобы при возобновлении продолжить чтение с нужного места.
- `merge` — настройки тай-брейка при совпадении меток времени (`nextSourceOnEqualTs`).
- `meta` — метаданные (символ, опциональная заметка) + отметка времени создания `createdAtMs`.

## Быстрая проверка

Для end-to-end проверки используйте smoke-сценарий:

```bash
node examples/06-resume-from-checkpoint/smoke.ts
```

Скрипт вызывает `save.js`, затем `resume.js`, убеждается, что файл чекпоинта существует и в stdout присутствует маркер `RESUME_OK`. Успешное завершение сопровождается строкой `EX06_RESUME_SMOKE_OK`.
