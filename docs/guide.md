# TradeForge Guide

## Архитектура пакетов

- **`@tradeforge/core`** — движок симуляции. Содержит службы работы со счетами (`AccountsService`), ордерами (`OrdersService`), движок матчинга и модель комиссий. Управляет временной шкалой, выполняет `runReplay` и предоставляет API для создания/загрузки чекпоинтов.
- **`@tradeforge/io-binance`** — набор ридеров исторических данных Binance. Поддерживает CSV/JSON/JSONL, умеет нормализовать поля в формат, понятный `core`, и предоставляет курсоры (`createJsonlCursorReader`) для возобновляемых прогонов.
- **`@tradeforge/cli`** — консольный инструмент, собирающий pipeline из ридеров и движка. Реализует команду `tf simulate`, управление часами, авто-чекпоинты и вывод статистики.
- **`@tradeforge/svc`** — REST-обёртка над движком. Поднимает Fastify-сервер с маршрутами для управления счетами и ордерами и использует те же сервисы `core` в памяти.

Компоненты связаны минимальным числом зависимостей: CLI и сервис подключают `core` напрямую и опционально используют `io-binance` для чтения исторических данных.

## Консервативная модель исполнения

MVP-1 придерживается консервативного подхода: симулятор матчит ордера только по фактическим сделкам (`TradeEvent`). Данные стакана (`DepthDiff`) используются для тай-брейков и валидации последовательности, но **не влияют** на сам факт исполнения — это гарантирует, что симуляция не создаёт ликвидность из воздуха.

Флаги CLI отражают этот подход:

- `--treat-limit-as-maker` (включён по умолчанию) позволяет считать наши лимитные ордера поставщиками ликвидности, если они не противоречат агрессору.
- `--strict-conservative` устанавливает коэффициент участия в 0, тем самым отключая исполнение в пограничных ситуациях.
- `--use-aggressor-liquidity` вручную включает более агрессивный режим, когда объём агрессора допускается как источник ликвидности.

## Детерминизм и таймлайн

Чтобы добиться повторяемости:

- Потоки сделок и стакана объединяются в `createMergedStream` с явным порядком разрешения конфликтов. По умолчанию при совпадении меток времени отдаётся приоритет стакану (`--prefer-depth-on-equal-ts`), но это можно переопределить.
- Все суммы и цены хранятся как `bigint`. При сериализации (чекпоинты, REST, CLI) значения переводятся в строки — так исключается потеря точности из-за плавающей запятой.
- Источники данных упорядочиваются детерминированно (глобальное сортирование имен при чтении архива, фиксированный порядок файлов). JSONL-ридер в zip-файлах требует одиночного entry и сортирует содержимое.
- При возобновлении симуляции из чекпоинта сохраняется `nextSourceOnEqualTs` — флаг, указывающий какой поток должен идти первым при совпадающих метках времени.

## Ограничения форматов и курсоров

- `createReader` поддерживает `csv`, `json`, `jsonl` и авто-детект по расширению. Однако курсоры (`CheckpointV1`) гарантированно работают **только** с JSON Lines (`*.jsonl`, `*.jsonl.gz`, `*.jsonl.zip`). При использовании CSV/JSON данные можно прочитать, но позицию в файле восстановить нельзя — чекпоинт сохранит состояние движка, но потоки придётся переигрывать с начала.
- Архивы `.jsonl.zip` должны содержать ровно один файл с расширением `.jsonl`. Многофайловые архивы пока не поддерживаются (ограничение из PR-8b).
- JSONL-ридер проверяет монотонность меток времени (при включённой опции `assertMonotonicTimestamps`) и выбрасывает ошибку при нарушениях — это помогает поддерживать детерминизм.

## Checkpoint v1

Чекпоинт (`CheckpointV1`) содержит:

- `meta` — символ и, опционально, заметку пользователя.
- `engine` и `state` — сериализованные снимки движка и публичного состояния `ExchangeState`.
- `cursors` — позиция в потоках сделок/стакана (файл, entry, индекс записи). Для не-JSONL источников курсоры отсутствуют.
- `merge.nextSourceOnEqualTs` — правило тай-брейка, с которым была создана симуляция.

### Создание

CLI автоматически строит чекпоинт при указании `--checkpoint-save`. Можно задать интервалы автосохранения по событиям (`--cp-interval-events`) или реальному времени (`--cp-interval-wall-ms`). При отсутствии интервалов чекпоинт сохраняется только по завершении прогона.

### Загрузка

`--checkpoint-load` восстанавливает состояние движка и применяет курсоры. Необходимо передать те же входные файлы, что использовались ранее, чтобы курсоры совпали: JSONL-ридер ищет файл по имени и entry внутри архива. Если курсор найден, симуляция продолжится с нужной строки; иначе будет выброшено исключение.

### Ограничения

- В версии v1 гарантируются только JSONL-источники. Поддержка CSV/JSON и многофайловых архивов запланирована на будущие релизы.
- При изменении порядка файлов или их содержимого курсор станет недействительным.

## Типовой user-flow

1. **Подготовка данных** — выгрузить сделки/стакан Binance и преобразовать в JSONL (или воспользоваться `@tradeforge/io-binance` для конвертации).
2. **Первый прогон** — запустить `tf simulate` с `--checkpoint-save`, указав входные файлы и желаемые интервалы автосохранения.
3. **Автосохранение** — дождаться сообщения `checkpoint saved to …` и остановить процесс (Ctrl+C), если нужно перенести расчёт.
4. **Возобновление** — запустить `tf simulate --checkpoint-load <файл>` с теми же `--trades`/`--depth`, чтобы продолжить симуляцию.
5. **Интеграция с REST** — при необходимости поднять `@tradeforge/svc` и отдавать полученные отчёты через HTTP, используя формат строк для чисел.

Такой процесс обеспечивает детерминизм: при неизменных данных и настройках симулятор даёт идентичные результаты, а чекпоинты позволяют разделять длительные прогоны на несколько сессий.
